- name: Generate the list of expected manifest files from the live cluster
  hosts: localhost
  gather_facts: false
  connection: local

  vars:
    # --- Git Configuration ---
    git_ssh_key_path: "{{ lookup('env', 'ANSIBLE_PRIVATE_KEY_FILE') }}"
    github_user: "kseremet"
    repo_name: "gitops-vm-dr-manifests"
    repo_url: "git@github.com:{{ github_user }}/{{ repo_name }}.git" # SSH URL

    # --- Selector for discovery (optional) ---
    # Can be passed as an extra var: -e "namespace_selector=environment=prod"
    namespace_selector: ""

    # --- Kustomize Configuration ---
    target_cluster_name: cls2

  tasks:
    - name: Get list of selected namespaces if a selector is provided
      kubernetes.core.k8s_info:
        kind: Namespace
        label_selectors: "{{ (namespace_selector | length > 0) | ternary(namespace_selector.split(','), omit) }}"
      register: selected_namespaces
      when: namespace_selector | length > 0

    - name: Get all DR-enabled VMs from selected namespaces
      kubernetes.core.k8s_info:
        kind: VirtualMachine
        api_version: kubevirt.io/v1
        namespace: "{{ item.metadata.name }}"
        label_selectors:
          - "dr.demojam.com/enabled=true"
      loop: "{{ selected_namespaces.resources }}"
      loop_control:
        label: "{{ item.metadata.name }}"
      register: vm_list_from_selected_ns
      when: namespace_selector | length > 0

    - name: Get all DR-enabled VMs from ALL namespaces (if namespace selector is not provided)
      kubernetes.core.k8s_info:
        kind: VirtualMachine
        api_version: kubevirt.io/v1
        label_selectors:
          - "dr.demojam.com/enabled=true"
      register: vm_list_from_all_ns
      when: namespace_selector | length == 0

    - name: Consolidate list of VMs (if selector was used)
      ansible.builtin.set_fact:
        vms_to_process: "{{ vm_list_from_selected_ns.results | map(attribute='resources') | flatten }}"
      when: namespace_selector | length > 0

    - name: Consolidate list of VMs (if no selector was used)
      ansible.builtin.set_fact:
        vms_to_process: "{{ vm_list_from_all_ns.resources }}"
      when: namespace_selector | length == 0

    - name: Initialize the list of expected filenames
      ansible.builtin.set_fact:
        expected_manifest_filenames: []

    # --- Pre-fetch all PVCs for efficiency ---
    - name: Get all PVCs from the target namespaces
      kubernetes.core.k8s_info:
        api_version: v1
        kind: PersistentVolumeClaim
      register: all_pvc_info

    - name: Generate a list of unique keys for the lookup dictionary
      ansible.builtin.set_fact:
        pvc_keys: "{{ all_pvc_info.resources | map(attribute='metadata.namespace') | zip(all_pvc_info.resources | map(attribute='metadata.name')) | map('join', '/') | list }}"

    - name: Create the fast lookup dictionary using the generated keys
      ansible.builtin.set_fact:
        pvc_lookup_dict: "{{ dict(pvc_keys | zip(all_pvc_info.resources)) }}"

    # --- FILENAME GENERATION LOOP ---
    - name: Generate expected filenames for each VM
      ansible.builtin.include_tasks:
        file: tasks/generate_expected_filenames.yaml
      loop: "{{ vms_to_process }}"
      loop_control:
        loop_var: vm_object
        label: "{{ vm_object.metadata.name }}"

    - name: Display the final list of all expected manifest files
      ansible.builtin.debug:
        var: expected_manifest_filenames

    - name: Create a unique temporary directory for the Git clone
      ansible.builtin.tempfile:
        state: directory
        prefix: "gitops_dr_"
      register: temp_clone_dir

    - name: Set the clone directory path as a fact
      ansible.builtin.set_fact:
        clone_dir: "{{ temp_clone_dir.path }}"

    - name: Perform a shallow clone of the Git repository
      ansible.builtin.git:
        repo: "{{ repo_url }}"
        dest: "{{ clone_dir }}"
        depth: 1
        clone: true
        update: true
        key_file: "{{ git_ssh_key_path }}"
        accept_hostkey: true

    - name: Find all manifest files currently in the Git repository
      ansible.builtin.find:
        paths: "{{ clone_dir }}/vms/base/"
        patterns: "*.yaml"
        excludes: "kustomization.yaml" # Exclude the kustomization file itself
        recurse: true
      register: git_manifests

    - name: Create simple lists of relative file paths for comparison
      ansible.builtin.set_fact:
        # Creates a list like ['default/vm-myvm.yaml', 'default/pvc-mydisk.yaml']
        actual_manifest_paths: "{{ git_manifests.files | map(attribute='path') | map('relpath', clone_dir + '/vms/base') | list }}"

    - name: Display the actual list of all manifest files in the git repo
      ansible.builtin.debug:
        var: actual_manifest_paths

    - name: Identify orphan files using the 'difference' filter
      ansible.builtin.set_fact:
        orphan_files: "{{ actual_manifest_paths | difference(expected_manifest_filenames) }}"

    - name: Display the list of orphan files found in the Git repository
      ansible.builtin.debug:
        var: orphan_files

    - name: Clean up each orphan file and its associated resources
      when: orphan_files | length > 0
      block:
        - name: Get a unique list of namespaces containing orphans
          ansible.builtin.set_fact:
            orphan_namespaces: "{{ orphan_files | map('dirname') | unique | list }}"

        - name: Display the list of orphan namespaces
          ansible.builtin.debug:
            var: orphan_namespaces

        # --- Step 1: Process each individual orphan file ---
        - name: Process each orphan file for cleanup
          ansible.builtin.include_tasks:
            file: tasks/cleanup_orphan_file.yaml
          loop: "{{ orphan_files }}"
          loop_control:
            loop_var: orphan_file
            label: "{{ orphan_file }}"

        # --- Step 2: Clean up any newly empty directories ---
        - name: Check for and clean up any newly empty namespace directories
          ansible.builtin.include_tasks:
            file: tasks/cleanup_empty_dir.yaml
          loop: "{{ orphan_namespaces }}"
          loop_control:
            loop_var: namespace_dir
            label: "{{ namespace_dir }}"

    - name: Check for any changes in the repository
      ansible.builtin.command: git status --porcelain
      args:
        chdir: "{{ clone_dir }}"
      register: git_status
      changed_when: git_status.stdout | length > 0

    - name: Commit and push all cleanup changes
      when: git_status.changed
      block:
        - name: Add all changes to git staging
          ansible.builtin.command: git add .
          args:
            chdir: "{{ clone_dir }}"

        - name: Commit changes
          ansible.builtin.command: "git commit -m 'Automated GC: Cleaned up orphan resources'"
          args:
            chdir: "{{ clone_dir }}"

        - name: Push changes to the remote repository
          ansible.builtin.shell: git push origin HEAD
          args:
            chdir: "{{ clone_dir }}"
          environment:
            GIT_SSH_COMMAND: "ssh -i {{ git_ssh_key_path }} -o StrictHostKeyChecking=no"

